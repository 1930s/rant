using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;

using Processus.Blueprints;
using Processus.Compiler;

using Stringes;

namespace Processus
{
    // The return value is returned by the blueprint that executes the tag. If it's true, the interpreter will skip to the top of the state stack.
    internal delegate bool TagFunc(Interpreter interpreter, Source source, Stringe tagName, Argument[] args);

    internal partial class Interpreter
    {
        internal static readonly Dictionary<string, TfDefs> TagFuncs;

        static Interpreter()
        {
            TagFuncs = new Dictionary<string, TfDefs>();

            TagFuncs["rep"] = TagFuncs["r"] = new TagDef(Repeat, ParamFlags.String);
            TagFuncs["num"] = TagFuncs["n"] = new TagDef(Number, ParamFlags.String, ParamFlags.String);
            TagFuncs["sep"] = TagFuncs["s"] = new TagDef(Separator, ParamFlags.Tokens);
            TagFuncs["before"] = new TagDef(Before, ParamFlags.Tokens);
            TagFuncs["after"] = new TagDef(After, ParamFlags.Tokens);
            TagFuncs["chance"] = new TagDef(Chance, ParamFlags.String);
            TagFuncs["sync"] = new TagDef(Sync, ParamFlags.String, ParamFlags.String);
            TagFuncs["desync"] = new TagDef(Desync);
            TagFuncs["pin"] = new TagDef(Pin, ParamFlags.String);
            TagFuncs["unpin"] = new TagDef(Unpin, ParamFlags.String);
            TagFuncs["step"] = new TagDef(Step, ParamFlags.String);
            TagFuncs["reset"] = new TagDef(Reset, ParamFlags.String);
            TagFuncs["first"] = new TagDef(First, ParamFlags.Tokens);
            TagFuncs["last"] = new TagDef(Last, ParamFlags.Tokens);
            TagFuncs["middle"] = new TagDef(Middle, ParamFlags.Tokens);
            TagFuncs["notfirst"] = new TagDef(NotFirst, ParamFlags.Tokens);
            TagFuncs["notlast"] = new TagDef(NotLast, ParamFlags.Tokens);
            TagFuncs["notmiddle"] = new TagDef(NotMiddle, ParamFlags.Tokens);
            TagFuncs["odd"] = new TagDef(Odd, ParamFlags.Tokens);
            TagFuncs["even"] = new TagDef(Even, ParamFlags.Tokens);
            TagFuncs["nth"] = new TagDef(Nth, ParamFlags.String, ParamFlags.String, ParamFlags.Tokens);
            TagFuncs["repnum"] = TagFuncs["rn"] = new TagDef(RepNum);
            TagFuncs["repindex"] = TagFuncs["ri"] = new TagDef(RepIndex);
            TagFuncs["repcount"] = TagFuncs["rc"] = new TagDef(RepCount);
            TagFuncs["alt"] = new TagDef(Alt, ParamFlags.Tokens, ParamFlags.Tokens);
            TagFuncs["match"] = new TagDef(ReplaceMatch);
            TagFuncs["group"] = new TagDef(ReplaceGroup, ParamFlags.String);
            TagFuncs["arg"] = new TagDef(Arg, ParamFlags.String);
            TagFuncs["numfmt"] = new TagDef(NumFmt, ParamFlags.String);
            TagFuncs["caps"] = new TagDef(Caps, ParamFlags.String);
            TagFuncs["capsinfer"] = new TagDef(CapsInfer, ParamFlags.String);
            TagFuncs["out"] = new TagDef(Out, ParamFlags.String, ParamFlags.String);
            TagFuncs["close"] = new TagDef(Close, ParamFlags.String);
            TagFuncs["extern"] = new TagDef(Extern, ParamFlags.String);
        }

        private static bool Extern(Interpreter interpreter, Source source, Stringe tagname, Argument[] args)
        {
            var name = args[0].GetString();
            var result = interpreter.Engine.Hooks.Call(name);
            if (result == null)
            {
                throw new ProcessusException(source, tagname, "A hook with the name '" + name + "' does not exist.");
            }
            interpreter.Print(result);
            return false;
        }

        private static bool Reset(Interpreter interpreter, Source source, Stringe tagName, Argument[] args)
        {
            interpreter.Reset(args[0].GetString());
            return false;
        }

        private static bool CapsInfer(Interpreter interpreter, Source source, Stringe tagname, Argument[] args)
        {
            // TODO: Make capsinfer properly infer "first" capitalization given multiple sentences. Currently, it mistakes it for "word" mode.
            var words = Regex.Matches(args[0].GetString(), @"\w+").OfType<Match>().Select(m => m.Value).ToArray();
            int wCount = words.Length;
            int uCount = 0;
            int fwCount = 0;
            bool firstCharIsUpper = false;
            for (int i = 0; i < wCount; i++)
            {
                if (words[i].All(Char.IsUpper))
                {
                    uCount++;
                }
                if (Char.IsUpper(words[i][0]))
                {
                    fwCount++;
                    if (i == 0) firstCharIsUpper = true;
                }
            }
            if (uCount == wCount)
            {
                interpreter.CurrentState.Output.SetCaps(Capitalization.Upper);
            }
            else if (wCount > 1 && fwCount == wCount)
            {
                interpreter.CurrentState.Output.SetCaps(Capitalization.Word);
            }
            else if (firstCharIsUpper)
            {
                interpreter.CurrentState.Output.SetCaps(Capitalization.First);
            }
            return false;
        }

        private static bool Close(Interpreter interpreter, Source source, Stringe tagname, Argument[] args)
        {
            interpreter.CurrentState.Output.PopChannel(args[0].GetString());
            return false;
        }

        private static bool Out(Interpreter interpreter, Source source, Stringe tagname, Argument[] args)
        {
            ChannelVisibility cv;
            var cv_str = args[1].GetString();
            if (!Enum.TryParse(Util.NameToCamel(cv_str), out cv))
            {
                throw new ProcessusException(source, tagname, "Invalid channel visibility option '" + cv_str + "'");
            }
            interpreter.CurrentState.Output.PushChannel(args[0].GetString(), cv);
            return false;
        }

        private static bool Caps(Interpreter interpreter, Source source, Stringe tagname, Argument[] args)
        {
            Capitalization caps;
            var caps_str = args[0].GetString();
            if (!Enum.TryParse(Util.NameToCamel(caps_str), out caps))
            {
                throw new ProcessusException(source, tagname, "Invalid capitalization format '" + caps_str + "'");
            }
            interpreter.CurrentState.Output.SetCaps(caps);
            return false;
        }

        private static bool NumFmt(Interpreter interpreter, Source source, Stringe tagname, Argument[] args)
        {
            NumberFormat fmt;
            var fmtstr = args[0].GetString();
            if (!Enum.TryParse(Util.NameToCamel(fmtstr), out fmt))
            {
                throw new ProcessusException(source, tagname, "Invalid number format '" + fmtstr + "'");
            }
            interpreter.NumberFormat = fmt;
            return false;
        }

        private static bool Arg(Interpreter interpreter, Source source, Stringe tagname, Argument[] args)
        {
            if (!interpreter.SubArgStack.Any())
                throw new ProcessusException(source, tagname, "Tried to access arguments outside of a subroutine body.");

            Argument arg;
            var argName = args[0].GetString().Trim();
            if (!interpreter.SubArgStack.Peek().TryGetValue(argName, out arg))
                throw new ProcessusException(source, tagname, "Could not find argument '" + argName + "'.");

            // Argument is string
            if (arg.Flags == ParamFlags.String)
            {
                interpreter.Print(arg.GetString());
                return false;
            }
            
            // Argument is tokens
            interpreter.PushState(State.CreateDerivedShared(source, arg.GetTokens(), interpreter));
            return true;
        }

        private static bool ReplaceGroup(Interpreter interpreter, Source source, Stringe tagname, Argument[] args)
        {
            interpreter.Print(interpreter.GetMatchString(args[0].GetString()));
            return false;
        }

        private static bool ReplaceMatch(Interpreter interpreter, Source source, Stringe tagname, Argument[] args)
        {
            interpreter.Print(interpreter.GetMatchString());
            return false;
        }

        private static bool Alt(Interpreter interpreter, Source source, Stringe tagname, Argument[] args)
        {
            var testState = State.CreateDerivedDistinct(source, args[0].GetTokens(), interpreter,
                interpreter.CurrentState.Output);
            testState.AddPostBlueprint(new AltBlueprint(interpreter, testState, args[1].GetTokens()));
            interpreter.PushState(testState);
            return true;
        }

        private static bool RepCount(Interpreter interpreter, Source source, Stringe tagname, Argument[] args)
        {
            if (interpreter.CurrentRepeater == null) throw new ProcessusException(source, tagname, "No active repeater.");
            interpreter.Print(interpreter.FormatNumber(interpreter.CurrentRepeater.Count));
            return false;
        }

        private static bool RepIndex(Interpreter interpreter, Source source, Stringe tagname, Argument[] args)
        {
            if (interpreter.CurrentRepeater == null) throw new ProcessusException(source, tagname, "No active repeaters.");
            interpreter.Print(interpreter.FormatNumber(interpreter.CurrentRepeater.Index));
            return false;
        }

        private static bool RepNum(Interpreter interpreter, Source source, Stringe tagname, Argument[] args)
        {
            if (interpreter.CurrentRepeater == null) throw new ProcessusException(source, tagname, "No active repeaters.");
            interpreter.Print(interpreter.FormatNumber(interpreter.CurrentRepeater.Index + 1));
            return false;
        }

        private static bool Nth(Interpreter interpreter, Source source, Stringe tagname, Argument[] args)
        {
            int offset, interval;
            if (!Int32.TryParse(args[0].GetString(), out interval))
            {
                throw new ProcessusException(source, tagname, "Invalid interval value.");
            }

            if (interval <= 0)
            {
                throw new ProcessusException(source, tagname, "Interval must be greater than zero.");
            }

            if (!Int32.TryParse(args[1].GetString(), out offset))
            {
                throw new ProcessusException(source, tagname, "Invalid offset value.");
            }

            if (interpreter.CurrentRepeater == null || !interpreter.CurrentRepeater.Nth(offset, interval)) return false;
            interpreter.PushState(State.CreateDerivedDistinct(source, args[2].GetTokens(), interpreter, interpreter.CurrentState.Output));
            return true;
        }

        private static bool Even(Interpreter interpreter, Source source, Stringe tagname, Argument[] args)
        {
            if (interpreter.CurrentRepeater == null || !interpreter.CurrentRepeater.IsEven) return false;
            interpreter.PushState(State.CreateDerivedDistinct(source, args[0].GetTokens(), interpreter, interpreter.CurrentState.Output));
            return true;
        }

        private static bool Odd(Interpreter interpreter, Source source, Stringe tagname, Argument[] args)
        {
            if (interpreter.CurrentRepeater == null || !interpreter.CurrentRepeater.IsOdd) return false;
            interpreter.PushState(State.CreateDerivedDistinct(source, args[0].GetTokens(), interpreter, interpreter.CurrentState.Output));
            return true;
        }

        private static bool NotMiddle(Interpreter interpreter, Source source, Stringe tagname, Argument[] args)
        {
            if (interpreter.CurrentRepeater == null || interpreter.CurrentRepeater.IsFirst || interpreter.CurrentRepeater.IsLast) return false;
            interpreter.PushState(State.CreateDerivedDistinct(source, args[0].GetTokens(), interpreter, interpreter.CurrentState.Output));
            return true;
        }

        private static bool NotLast(Interpreter interpreter, Source source, Stringe tagname, Argument[] args)
        {
            if (interpreter.CurrentRepeater == null || interpreter.CurrentRepeater.IsLast) return false;
            interpreter.PushState(State.CreateDerivedDistinct(source, args[0].GetTokens(), interpreter, interpreter.CurrentState.Output));
            return true;
        }

        private static bool NotFirst(Interpreter interpreter, Source source, Stringe tagname, Argument[] args)
        {
            if (interpreter.CurrentRepeater == null || interpreter.CurrentRepeater.IsFirst) return false;
            interpreter.PushState(State.CreateDerivedDistinct(source, args[0].GetTokens(), interpreter, interpreter.CurrentState.Output));
            return true;
        }

        private static bool Middle(Interpreter interpreter, Source source, Stringe tagname, Argument[] args)
        {
            if (interpreter.CurrentRepeater == null || interpreter.CurrentRepeater.IsLast || interpreter.CurrentRepeater.IsFirst) return false;
            interpreter.PushState(State.CreateDerivedDistinct(source, args[0].GetTokens(), interpreter, interpreter.CurrentState.Output));
            return true;
        }

        private static bool Last(Interpreter interpreter, Source source, Stringe tagname, Argument[] args)
        {
            if (interpreter.CurrentRepeater == null || !interpreter.CurrentRepeater.IsLast) return false;
            interpreter.PushState(State.CreateDerivedDistinct(source, args[0].GetTokens(), interpreter, interpreter.CurrentState.Output));
            return true;
        }

        private static bool First(Interpreter interpreter, Source source, Stringe tagname, Argument[] args)
        {
            if (interpreter.CurrentRepeater == null || !interpreter.CurrentRepeater.IsFirst) return false;
            interpreter.PushState(State.CreateDerivedDistinct(source, args[0].GetTokens(), interpreter, interpreter.CurrentState.Output));
            return true;
        }

        private static bool Step(Interpreter interpreter, Source source, Stringe tagname, Argument[] args)
        {
            interpreter.Step(args[0].GetString());
            return false;
        }

        private static bool Unpin(Interpreter interpreter, Source source, Stringe tagname, Argument[] args)
        {
            interpreter.Unpin(args[0].GetString());
            return false;
        }

        private static bool Pin(Interpreter interpreter, Source source, Stringe tagname, Argument[] args)
        {
            interpreter.Pin(args[0].GetString());
            return false;
        }

        private static bool Desync(Interpreter interpreter, Source source, Stringe tagname, Argument[] args)
        {
            interpreter.Desync();
            return false;
        }

        private static bool Sync(Interpreter interpreter, Source source, Stringe tagname, Argument[] args)
        {
            var typeStr = args[1].GetString();
            SyncType type;
            if (!Enum.TryParse(typeStr, true, out type))
            {
                throw new ProcessusException(source, tagname, "Invalid synchronizer type: '" + typeStr + "'");
            }
            interpreter.Sync(args[0].GetString(), type);
            return false;
        }

        private static bool Chance(Interpreter interpreter, Source source, Stringe tagname, Argument[] args)
        {
            int a;
            if (!Int32.TryParse(args[0].GetString(), out a))
            {
                throw new ProcessusException(source, tagname, "Invalid chance number.");
            }
            interpreter.SetChance(a);
            return false;
        }

        private static bool After(Interpreter interpreter, Source source, Stringe tagname, Argument[] args)
        {
            interpreter.NextAttribs.After = args[0].GetTokens();
            return false;
        }

        private static bool Before(Interpreter interpreter, Source source, Stringe tagName, Argument[] args)
        {
            interpreter.NextAttribs.Before = args[0].GetTokens();
            return false;
        }

        private static bool Number(Interpreter interpreter, Source source, Stringe tagName, Argument[] args)
        {
            int a, b;
            if (!Int32.TryParse(args[0].GetString(), out a) || !Int32.TryParse(args[1].GetString(), out b))
            {
                throw new ProcessusException(source, tagName, "Range values could not be parsed. They must be numbers.");
            }
            interpreter.Print(interpreter.FormatNumber(interpreter.RNG.Next(a, b + 1)));
            return false;
        }

        private static bool Separator(Interpreter interpreter, Source source, Stringe tagName, Argument[] args)
        {
            interpreter.NextAttribs.Separator = args[0].GetTokens();
            return false;
        }

        private static bool Repeat(Interpreter interpreter, Source source, Stringe tagName, Argument[] args)
        {
            var reps = args[0].GetString().ToLower().Trim();
            if (reps == "each")
            {
                interpreter.NextAttribs.Repetitons = Repeater.Each;
                return false;
            }

            int num;
            if (!Int32.TryParse(reps, out num))
            {
                throw new ProcessusException(source, tagName, "Invalid repetition value '" + reps + "' - must be a number.");
            }
            if (num < 0)
            {
                throw new ProcessusException(source, tagName, "Repetition value cannot be negative.");
            }

            interpreter.NextAttribs.Repetitons = num;
            return false;
        }

        internal class TfDefs : IEnumerable<TagDef>
        {
            private readonly Dictionary<int, TagDef> _defs = new Dictionary<int, TagDef>();

            public void Add(TagDef def)
            {
                _defs[def.Parameters.Length] = def;
            }

            public TagDef GetDef(int paramCount)
            {
                TagDef def;
                return _defs.TryGetValue(paramCount, out def) ? def : null;
            }

            public IEnumerator<TagDef> GetEnumerator()
            {
                return _defs.Values.GetEnumerator();
            }

            IEnumerator IEnumerable.GetEnumerator()
            {
                return GetEnumerator();
            }

            public static implicit operator TfDefs(TagDef def)
            {
                return new TfDefs{def};
            }
        }

        internal class TagDef
        {
            private readonly int _paramCount;
            private readonly int _minArgCount;
            private readonly bool _hasMultiFlag;
            private readonly ParamFlags[] _parameters;
            private readonly TagFunc _func;

            public ParamFlags[] Parameters
            {
                get { return _parameters; }
            }

            public int ParamCount
            {
                get { return _paramCount; }
            }

            public int MinArgCount
            {
                get { return _minArgCount; }
            }

            public bool HasMultiFlag
            {
                get { return _hasMultiFlag; }
            }

            public TagDef(TagFunc func, params ParamFlags[] paramFlagses)
            {
                if (paramFlagses.Where((t, i) => i < paramFlagses.Length - 1 && t.HasFlag(ParamFlags.Multi)).Any())
                    throw new ArgumentException("The flag 'ParamType.Multi' is only valid on the last parameter.");

                _hasMultiFlag = _parameters.Any() && _parameters.Last().HasFlag(ParamFlags.Multi);
                _paramCount = paramFlagses.Length;
                _minArgCount = _hasMultiFlag ? _paramCount - 1 : _paramCount;
                _parameters = paramFlagses;
                _func = func;
            }

            public bool Invoke(Interpreter interpreter, Source source, Stringe tagName, Argument[] args)
            {
                return _func(interpreter, source, tagName, args);
            }
        }
    }
}